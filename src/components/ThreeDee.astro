---
export interface Props {
  models: {
    href: string;
    position: number[];
    animationEnabled?: boolean;
    animationAmplitude?: number;
    animationDuration?: number;
  }[];
  camera: {
    position: number[];
    fov?: number;
    near?: number;
    far?: number;
  };
  light: {
    position: number[];
    distance?: number;
    intensity?: number;
    decay?: number;
    color?: number;
  };
  class?: string;
}

const props = Astro.props;
---

<canvas
  class:list={["three-dee-canvas bg-transparent", props.class]}
  data-models={props.models.map((m) => m.href).join(" ")}
  data-models-position={props.models.map((m) => m.position.join(" ")).join("-")}
  data-models-animation-enabled={props.models
    .map((m) => m.animationEnabled)
    .join(" ")}
  data-models-animation-amplitude={props.models
    .map((m) => m.animationAmplitude)
    .join(" ")}
  data-models-animation-duration={props.models
    .map((m) => m.animationDuration)
    .join(" ")}
  data-camera-position={props.camera.position.join(" ")}
  data-camera-fov={props.camera.fov}
  data-camera-far={props.camera.far}
  data-camera-near={props.camera.near}
  data-light-position={props.light.position.join(" ")}
  data-light-distance={props.light.distance}
  data-light-intensity={props.light.intensity}
  data-light-decay={props.light.decay}
  data-light-color={props.light.color}
  width="500"
  height="300"
>
</canvas>

<script>
  import * as THREE from "three";

  import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
  import * as TWEEN from "three/examples/jsm/libs/tween.module";

  class ThreeDeeView {
    scene: THREE.Scene;
    renderer: THREE.WebGLRenderer;
    camera: THREE.PerspectiveCamera;
    models: THREE.Object3D[] = [];
    light: THREE.PointLight;
    animations: Array<TWEEN.Tween<THREE.Vector3> | null> = [];
    animationsConfig: {
      amplitude: number;
      durationMs: number;
      enabled: boolean;
    }[] = [];

    private static loader = new GLTFLoader();
    private static dracoLoader = new DRACOLoader();

    static {
      ThreeDeeView.dracoLoader.setDecoderPath("/gltf/");
      ThreeDeeView.dracoLoader.preload();
      ThreeDeeView.loader.setDRACOLoader(ThreeDeeView.dracoLoader);
    }

    private constructor(canvas: HTMLCanvasElement) {
      const data = canvas.dataset;
      this.scene = new THREE.Scene();

      this.camera = new THREE.PerspectiveCamera(
        this.parseNum(data.cameraFov, 50),
        canvas.width / canvas.height,
        this.parseNum(data.cameraNear, 0.1),
        this.parseNum(data.cameraFar, 100)
      );
      this.camera.position.copy(this.parsePosition(data.cameraPosition!));

      this.light = new THREE.PointLight(
        this.parseNum(data.lightColor, 0xffffff, 16),
        this.parseNum(data.lightIntensity, 1),
        this.parseNum(data.lightDistance, 0),
        this.parseNum(data.lightDecay, 2)
      );
      this.light.position.copy(this.parsePosition(data.lightPosition!));

      this.scene.add(this.light);

      const amplitudes = data
        .modelsAnimationAmplitude!.split(" ")
        .map((s) => this.parseNum(s, 0.5));

      const durations = data
        .modelsAnimationDuration!.split(" ")
        .map((s) => this.parseNum(s, 2000));

      const enabled = data
        .modelsAnimationEnabled!.split(" ")
        .map((s) => (s === "" || s === "true" ? true : false));

      for (let i = 0; i < amplitudes.length; i++) {
        this.animationsConfig.push({
          amplitude: amplitudes[i],
          durationMs: durations[i],
          enabled: enabled[i],
        });
      }

      this.renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        alpha: true,
        antialias: true,
      });
      this.renderer.setSize(canvas.width, canvas.height);
    }

    static async createAsync(canvas: HTMLCanvasElement) {
      const instance = new ThreeDeeView(canvas);
      await instance.parseModels(canvas);
      instance.renderer.render(instance.scene, instance.camera);
      instance.animate();

      for (let i = 0; i < instance.models.length; i++) {
        if (!instance.animationsConfig[i].enabled) {
          instance.animations.push(null);
          continue;
        }

        instance.animations.push(
          new TWEEN.Tween(instance.models[i].position)
            .to(
              {
                y:
                  instance.models[i].position.y +
                  instance.animationsConfig[i].amplitude,
              },
              instance.animationsConfig[i].durationMs
            )
            .repeat(Infinity)
            .yoyo(true)
            .easing(TWEEN.Easing.Sinusoidal.InOut)
        );
        instance.animations[i]?.start();
      }

      return instance;
    }

    private animate() {
      requestAnimationFrame(this.animate.bind(this));

      TWEEN.update();

      this.render();
    }

    private render() {
      this.renderer.render(this.scene, this.camera);
    }

    private parseNum(
      str: string | undefined,
      fallback: number,
      radix?: number
    ) {
      if (str === undefined) return fallback;
      const number = parseInt(str, radix);
      if (isNaN(number)) return fallback;
      return number;
    }

    private async parseModels(canvas: HTMLCanvasElement) {
      const positions = canvas.dataset
        .modelsPosition!.split("-")
        .map((p) => this.parsePosition(p));

      const models = canvas.dataset.models!.split(" ");

      for (let i = 0; i < models.length; i++) {
        const obj = await this.loadModel(models[i]);
        obj.position.copy(positions[i]);
        this.models.push(obj);
        this.scene.add(obj);
      }
    }

    private loadModel(url: string) {
      return new Promise<THREE.Object3D>((resolve, reject) => {
        ThreeDeeView.loader.load(
          url,
          (gltf) => {
            resolve(gltf.scene);
          },
          undefined,
          reject
        );
      });
    }

    /** Expects position in format "x y z" */
    private parsePosition(position: string) {
      const xyzStr = position.split(" ");
      const coordinates = xyzStr.map((coordinate) => parseInt(coordinate, 10));
      return new THREE.Vector3(coordinates[0], coordinates[1], coordinates[2]);
    }
  }

  const canvases: NodeListOf<HTMLCanvasElement> =
    document.querySelectorAll(".three-dee-canvas");

  const threeDeeViews: ThreeDeeView[] = [];

  canvases.forEach(async (canvas) => {
    threeDeeViews.push(await ThreeDeeView.createAsync(canvas));
  });
</script>
